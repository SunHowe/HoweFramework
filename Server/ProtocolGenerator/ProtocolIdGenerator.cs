using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ProtocolGenerator
{
    [Generator]
    public class ProtocolIdGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 第一步：筛选所有实现了IMessage接口的类
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => IsClassWithInterface(node),
                    transform: (ctx, _) => GetClassSymbol(ctx))
                .Where(m => m != null);

            // 第二步：收集所有类并生成ID
            var classesWithIds = classDeclarations
                .Collect()
                .Select((classes, _) => GenerateClassIds(classes!));

            // 第三步：生成输出文件
            context.RegisterSourceOutput(classesWithIds, (spc, source) => GenerateOutput(spc, source));
        }

        private static bool IsClassWithInterface(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDecl &&
                   classDecl.BaseList?.Types.Count > 0;
        }

        private static INamedTypeSymbol GetClassSymbol(GeneratorSyntaxContext context)
        {
            var classDecl = (ClassDeclarationSyntax)context.Node;
            var model = context.SemanticModel;
            var typeSymbol = model.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;

            var iMessageInterface = model.Compilation.GetTypeByMetadataName("Protocol.IProtocol");
            if (iMessageInterface == null)
            {
                return null;
            }

            // 如果是抽象类则忽略。
            if (typeSymbol.IsAbstract)
            {
                return null;
            }

            return typeSymbol?.AllInterfaces.Any(i =>
                i.Equals(iMessageInterface, SymbolEqualityComparer.Default)) == true
                ? typeSymbol
                : null;
        }

        private static Dictionary<INamedTypeSymbol, ushort> GenerateClassIds(ImmutableArray<INamedTypeSymbol> classes)
        {
            var classToIdMap = new Dictionary<INamedTypeSymbol, ushort>(SymbolEqualityComparer.Default);
            var sortedClassList = classes.ToList();
            sortedClassList.Sort((a, b) => string.CompareOrdinal(a.Name, b.Name));

            ushort id = 1;
            foreach (var classSymbol in sortedClassList)
            {
                classToIdMap.Add(classSymbol, id++);
            }

            return classToIdMap;
        }

        private static void GenerateOutput(SourceProductionContext context,
            Dictionary<INamedTypeSymbol, ushort> classToIdMap)
        {
            if (classToIdMap.Count <= 0)
            {
                return;
            }

            // 1. 为每个类生成partial类文件
            foreach (var pair in classToIdMap)
            {
                GeneratePartialClassFile(context, pair.Key, pair.Value);
            }

            // 2. 生成协议枚举类
            GenerateProtocolEnum(context, classToIdMap);

            // 3. 生成双向查询类
            GenerateProtocolBinder(context, classToIdMap);
        }

        private static void GeneratePartialClassFile(
            SourceProductionContext context,
            INamedTypeSymbol classSymbol,
            ushort protocolId)
        {
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            string className = classSymbol.Name;

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine($"namespace {namespaceName}");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine($"    public partial class {className}");
            sourceBuilder.AppendLine("    {");

            #region [属性]
            sourceBuilder.AppendLine($"        public const ushort ProtocolId = {protocolId};");
            sourceBuilder.AppendLine($"        public override int Id => {protocolId};");

            // 检查是否实现了IProtocolResponse接口
            var IProtocolResponseInterface = classSymbol.ContainingAssembly.GetTypeByMetadataName("Protocol.IProtocolResponse");
            var IProtocolRequestInterface = classSymbol.ContainingAssembly.GetTypeByMetadataName("Protocol.IProtocolRequest");
            var isResponseType = IProtocolResponseInterface != null &&
                                 classSymbol.AllInterfaces.Any(i =>
                                     i.Equals(IProtocolResponseInterface, SymbolEqualityComparer.Default));
            var isRequestType = IProtocolRequestInterface != null &&
                                classSymbol.AllInterfaces.Any(i =>
                                    i.Equals(IProtocolRequestInterface, SymbolEqualityComparer.Default));
            if (isResponseType)
            {
                sourceBuilder.AppendLine("        [MemoryPack.MemoryPackIgnore]");
                sourceBuilder.AppendLine("        public int ErrorCode { get; set; }");

                sourceBuilder.AppendLine("        [MemoryPack.MemoryPackIgnore]");
                sourceBuilder.AppendLine("        public int RequestId { get; set; }");
            }
            else if (isRequestType)
            {
                sourceBuilder.AppendLine("        [MemoryPack.MemoryPackIgnore]");
                sourceBuilder.AppendLine("        public int RequestId { get; set; }");
            }

            #endregion

            #region [Create方法]

            sourceBuilder.Append($"        public static {className} Create");
            sourceBuilder.Append("(");

            // 遍历所有属性，将其作为Create方法的参数，且提供默认值。
            var isFirst = true;
            foreach (var property in classSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                if (!isFirst)
                {
                    sourceBuilder.Append(", ");
                }
                sourceBuilder.Append($"{property.Type.ToDisplayString()} {property.Name.CamelCase()} = default");
                isFirst = false;
            }

            sourceBuilder.Append(")");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("        {");

            sourceBuilder.AppendLine("            #if NETCOREAPP");
            sourceBuilder.AppendLine($"            var protocol = new {className}();");
            sourceBuilder.AppendLine("            #else");
            sourceBuilder.AppendLine($"            var protocol = HoweFramework.ReferencePool.Acquire<{className}>();");
            sourceBuilder.AppendLine("            #endif");

            foreach (var property in classSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                sourceBuilder.AppendLine($"            protocol.{property.Name} = {property.Name.CamelCase()};");
            }

            sourceBuilder.AppendLine("            return protocol;");
            sourceBuilder.AppendLine("        }");

            if (isResponseType)
            {
                // 单独创建一个只包含ErrorCode参数的方法。
                sourceBuilder.AppendLine($"        public static {className} Create(int errorCode)");
                sourceBuilder.AppendLine("        {");
                sourceBuilder.AppendLine("            #if NETCOREAPP");
                sourceBuilder.AppendLine($"            var protocol = new {className}();");
                sourceBuilder.AppendLine("            #else");
                sourceBuilder.AppendLine($"            var protocol = HoweFramework.ReferencePool.Acquire<{className}>();");
                sourceBuilder.AppendLine("            #endif");
                sourceBuilder.AppendLine("            protocol.ErrorCode = errorCode;");
                sourceBuilder.AppendLine("            return protocol;");
                sourceBuilder.AppendLine("        }");
            }

            #endregion

            #region [Clear方法]

            sourceBuilder.AppendLine("        public override void Clear()");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            base.Clear();");

            if (isResponseType)
            {
                sourceBuilder.AppendLine("            RequestId = default;");
                sourceBuilder.AppendLine("            ErrorCode = default;");
            }
            else if (isRequestType)
            {
                sourceBuilder.AppendLine("            RequestId = default;");
            }

            // 遍历所有属性，并将其设置为default。

            foreach (var property in classSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                sourceBuilder.AppendLine($"            {property.Name} = default;");
            }

            sourceBuilder.AppendLine("        }");

            #endregion

            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine("}");

            string fileName = $"{namespaceName}_{className}_ProtocolId.g.cs";
            context.AddSource(fileName, SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }

        private static void GenerateProtocolEnum(
            SourceProductionContext context,
            Dictionary<INamedTypeSymbol, ushort> classToIdMap)
        {
            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine("namespace Protocol");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("    public enum ProtocolId : ushort");
            sourceBuilder.AppendLine("    {");

            foreach (var pair in classToIdMap.OrderBy(x => x.Value))
            {
                string typeName = pair.Key.Name;
                sourceBuilder.AppendLine($"        {typeName} = {pair.Value},");
            }

            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine("}");

            context.AddSource("ProtocolIdEnum.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }

        private static void GenerateProtocolBinder(
            SourceProductionContext context,
            Dictionary<INamedTypeSymbol, ushort> classToIdMap)
        {
            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Collections.Generic;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace Protocol");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("    public static class ProtocolBinder");
            sourceBuilder.AppendLine("    {");
            sourceBuilder.AppendLine("        private static readonly Dictionary<Type, ushort> _typeToId = new();");
            sourceBuilder.AppendLine("        private static readonly Dictionary<ushort, Type> _idToType = new();");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("        static ProtocolBinder()");
            sourceBuilder.AppendLine("        {");

            foreach (var classSymbol in classToIdMap.Keys)
            {
                string typeName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                    .Replace("global::", "");
                sourceBuilder.AppendLine(
                    $"            _typeToId.Add(typeof({typeName}), (ushort)ProtocolId.{classSymbol.Name});");
                sourceBuilder.AppendLine(
                    $"            _idToType.Add((ushort)ProtocolId.{classSymbol.Name}, typeof({typeName}));");
            }

            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("        public static ushort? GetProtocolId<T>() => GetProtocolId(typeof(T));");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("        public static ushort? GetProtocolId(Type type)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return _typeToId.TryGetValue(type, out var id) ? id : null;");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("        public static Type? GetProtocolType(ushort protocolId)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine(
                "            return _idToType.TryGetValue(protocolId, out var type) ? type : null;");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine("}");

            context.AddSource("ProtocolBinder.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }
    }
}